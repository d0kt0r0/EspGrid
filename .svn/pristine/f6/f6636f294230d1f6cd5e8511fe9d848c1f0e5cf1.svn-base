/*
EspClock.sc -- SuperCollider class to provide a TempoClock connected to EspGrid
by David Ogborn <ogbornd@mcmaster.ca>
Version-date: 16 December 2013

Installation Instructions:
1. Place this file in your SuperCollider extensions folder
2. Launch SuperCollider (or Reboot Interpreter, or Recompile Class Library)

Examples of Use:
TempoClock.default = EspClock.new; // make the default clock a new EspClock
TempoClock.default.start; // if the beat is paused/was-never-started, make it go
TempoClock.default.tempo = 1.8; // change tempo in normal SC way (all changes go to EspGrid)
TempoClock.default.pause; // pause the beat
TempoClock.default.verbose = 0; // turn off console messages reporting on OSC received
TempoClock.default.status; // returns how close internal and external clocks are in seconds
TempoClock.default.versionDate; // returns a string identifying the version of this code
TempoClock.default.sendCycleLength(3)
*/

EspClock : TempoClock {

	// public properties (see TempoClock for all of it's properties/methods of course!)
	var <>verbose; // set this property to 1 to enable postln's, 0 to disable (default: 0)
	var <refClock; // an internal TempoClock that follows EspGrid "immediately" (don't schedule on this!)
	var <versionDate; // a string describing the update-date of this class definition

	// private variables:
	var defaultQueueSize;
	var send; // cached NetAddr for communication from SC to EspGrid
	var clockDiff; // difference between SystemClock.seconds and EspGrid time
	var lastTempo;
	var lastTime;
	var lastBeat;
	var <>syncSkipJack;
	var <>clockSkipJack;
	var <>tempoSkipJack;
	var <syncCount;

	// instance methods:

	init {
		| tempo,beats,seconds,queueSize |
		super.init(0.000000001,beats,seconds,queueSize);
		permanent = true;
		// refClock = TempoClock.new(tempo,beats,seconds,queueSize).permanent_(true); // *NOV13
		clockDiff = 0;
		syncCount = 0;
		versionDate = "16 December 2013 (0.49.5)";
		send = NetAddr("127.0.0.1",5510);
		verbose = 0;
		defaultQueueSize = queueSize;
		lastTempo = 0;
		lastTime = 0;

		OSCdef(\clockOffset,
			{
				| msg,time,addr,port |
				clockDiff = msg[1]+(msg[2]*0.000000001) + Date.getDate.rawSeconds - SystemClock.seconds;
				if(verbose==1,{msg.postln;});
			},
			"/clock/offset/r").permanent_(true);

		OSCdef(\espTempo,
			{
				| msg,time,addr,port |
				var bps = if(msg[1]==1,msg[2]/60,0.000000001); // SC doesn't pause, so... :(
				var systemTime = msg[3] + (msg[4]*0.000000001) - clockDiff; // adjust time to SystemClock epoch
				if(bps != lastTempo || systemTime != lastTime,
					{
						refClock = TempoClock.new(bps,msg[5],systemTime,defaultQueueSize);
						lastTempo = bps; lastTime = systemTime;
						if(verbose==1,{("new refClock: "+msg).postln;});
				});
				this.sync;
			},
			"/esp/tempo/r").permanent_(true);

		this.sendClockRequest;
		this.sendTempoRequest;
		this.reset;
	}

	reset {
		//if(syncSkipJack != nil, {syncSkipJack.stop;});
		if(tempoSkipJack != nil, {tempoSkipJack.stop;});
		if(clockSkipJack != nil, {clockSkipJack.stop;});
		//syncSkipJack = SkipJack.new( {this.sync;}, 0.025);
		tempoSkipJack = SkipJack.new( {this.sendTempoRequest;}, 0.1);
		clockSkipJack = SkipJack.new( {this.sendClockRequest;}, 10.0);
	}

	pause { this.sendBeatOff; }
	start { this.sendBeatOn; }
	tempo_ {|t| if(t<=5,{this.sendTempoChange(t)},{"tempo too high".postln;});}
	status { ^if(refClock!=nil, {refClock.beats - this.beats;}, "no refclock yet"); }

	// private methods:

	sync {
		var tempo = 0.000000001;

		if(refClock != nil,
			{
				var diff = refClock.beats - this.beats;
				tempo = if( diff.abs>0.00001,
					refClock.tempo + (diff*0.707),
					refClock.tempo);
				syncCount = syncCount + 1;

				//[refClock.beats,this.beats,refClock.tempo,tempo].postln;
			}
		);
		if(tempo<0.000000001,{tempo=0.000000001});
		this.setTempoAtSec(tempo,SystemClock.seconds);
	}

	sendTempoChange { |t| send.sendMsg("/esp/beat/tempo", t * 60); }
	sendCycleLength { |l| send.sendMsg("/esp/beat/cycleLength", l); }
	sendBeatOn { send.sendMsg("/esp/beat/on",1); }
	sendBeatOff { send.sendMsg("/esp/beat/on",0); }
	sendTempoRequest { send.sendMsg("/esp/tempo/q"); }
	sendClockRequest { send.sendMsg("/clock/offset/q"); }

}

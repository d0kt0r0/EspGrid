//
//  EspBeat.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspBeat.h"
#import "EspGridDefs.h"

@implementation EspBeat
@synthesize udp;
@synthesize osc;
@synthesize clock;
@synthesize kvc;

@synthesize on;
@synthesize tempo;
@synthesize downbeatTime;
@synthesize downbeatNumber;
@synthesize cycleLength;

@synthesize tempNumber;


-(id) init
{
    self = [super init];
    [self setOn:[NSNumber numberWithBool:NO]];
    [self setTempo:[NSNumber numberWithDouble:120.0]];
    [self setCycleLength:[NSNumber numberWithInt:4]];
    [self setDownbeatTime:[NSNumber numberWithDouble:EspGridTime()]];
    [self setDownbeatNumber:[NSNumber numberWithInt:0]];
    
    nextGridTime = -1.0;
    nextMachineTime = -1.0;
    nextMargin = 0.0;
    nextN = 0;
    nextL = 0;
    nextD = 0.0;
    
    beatsIssued = 0;
    
    lastN = 0;
    
    beatThread = [[NSThread alloc] initWithTarget:self selector:@selector(beatThreadMainMethod) object:nil];
    // [beatThread setThreadPriority:0.99]; // doesn't work on GNUstep
    [beatThread start];
    
    [self setValue:[NSNumber numberWithInt:0] forKey:@"on"];
    [self setValue:[NSNumber numberWithDouble:120.0] forKey:@"tempo"];
    
    return self;
}

-(void) beatThreadMainMethod
{
  [NSThread setThreadPriority:0.99]; // this works on GNUstep - does it work on OSX?
    [NSTimer scheduledTimerWithTimeInterval:0.010  
                                     target:self
                                   selector:@selector(beatThreadLoop:)
                                   userInfo:nil
                                    repeats:YES];
    [[NSRunLoop currentRunLoop] run];
}

-(void) beatThreadLoop:(NSTimer*)timer
{
    EspTimeType now = EspGridTime();
    if(nextN != 0 && (nextMargin - now) < 0.020) // lower values = more late beats, but lower CPU usage
    {
        while(now < nextMachineTime) { now = EspGridTime(); } // wait for beat        
        // perform the beat
        NSArray* msg = [NSArray arrayWithObjects:@"/esp/beat",
                        [NSNumber numberWithInt:nextN],
                        [NSNumber numberWithInt:nextL],
                        [NSNumber numberWithFloat:nextD],nil];
        [osc transmit:msg];
        if(nextN != lastN) beatsIssued++;
        
        // the lines below are just diagnostic
        if(nextN == lastN) // postProblem(@"*** double beat ***",self);
            NSLog(@"*** double beat ***"); // previous line not threadsafe
        lastN = nextN;
        nextN = 0; // having delivered the beat, a beat is no longer scheduled
        if(now > nextMargin) {
            // NSString* s = [NSString stringWithFormat:@"late beat by %.3f microseconds",(now-nextMachineTime)*1000000.0];
            NSLog(@"late beat by %.3f microseconds",(now-nextMachineTime)*1000000.0);
            // postLog(s, self); // not threadsafe!
        }
    }
    [self calculateNextBeat]; // can we just recalculate beat parameters everytime?
}

-(void) calculateNextBeat
{
    // this is the critical section where beat parameters are extracted
    bool beatOn = [on boolValue];
    double bpm = [tempo doubleValue];
    double downbeat = [downbeatTime doubleValue];
    nextL = [cycleLength intValue];
    // end critical section
    
    if( beatOn==YES && bpm>0.0 && nextL>0)
    { // parameters are good so schedule the next beat
        EspTimeType now = [clock currentAdjustedTime]; // 0.75 (with downbeat 1.0)
        nextD = 60.0/bpm; // 0.5
        if(now < downbeat)
        { // downbeat is in future
            // NSLog(@"future");
            nextGridTime = downbeat;
            nextN = 1;
        }
        else
        { // downbeat is in past
            double x = floor((now-downbeat)/nextD) + 1.0; // x is how many beats have passed since downbeat time, including downbeat
            // NSLog(@"past x=%f",x);
            nextGridTime = x * nextD + downbeat; // y is the time of the next beat on the basis of x // (x+1)=0 *nextD=0 + downbeat = 1
            nextN = ((int)x) % nextL + 1;
            if(nextN == 0) nextN = nextL;
        }
        nextMachineTime = [clock convertToMachineTime:nextGridTime];
        nextMargin = nextMachineTime + 0.0000025; // beats allowed up to 2.5 microseconds late (<1 sample @ 384kHZ)
        // Note: postWarning is not threadsafe, writes to variables of a different thread...
        // so for now we are using NsLog, but really this needs to be done better!
        if(nextGridTime - now < 0.0) NSLog(@"warning: next beat is in the past"); // that fixes the above problem, right?
        else if( nextGridTime - now < 0.010 ) NSLog(@"warning: imminent beat at end of beatThreadLoop %f",nextMachineTime-now);
    }
    else
    {
        nextN = 0;
    }
}

-(void) turnBeatOn
{
    if([on boolValue]==YES) return;
    EspTimeType stamp = [clock currentAdjustedTime] + 0.1; // fixed 100ms latency compensation
    [kvc setValue:[NSNumber numberWithDouble:stamp] forKeyPath:@"beat.downbeatTime"];
    [kvc setValue:[NSNumber numberWithBool:YES] forKeyPath:@"beat.on"];
    [kvc setValue:[NSNumber numberWithLong:beatsIssued] forKeyPath:@"beat.downbeatNumber"];
}

-(void) turnBeatOff
{
    if([on boolValue]==NO) return;
    lastN = 0;
    [kvc setValue:[NSNumber numberWithBool:NO] forKeyPath:@"beat.on"];
}

-(void) changeBeatState:(BOOL)newState
{
    if(newState)[self turnBeatOn];
    else [self turnBeatOff];
}

-(void) changeCycleLength:(int)newLength
{
    if(newLength == [cycleLength intValue])return;
    [kvc setValue:[NSNumber numberWithInt:newLength] forKeyPath:@"beat.cycleLength"];
}

-(void) changeTempo:(double)newBpm
{
    if([tempo doubleValue]==newBpm)return;
    
    if([on boolValue])
    {
        double now = [clock currentAdjustedTime];
        double downbeat = [downbeatTime doubleValue];     
        double bpm = [tempo doubleValue];
        if(bpm <= 0.0) bpm = 0.000001;
        double oldDuration = 60.0/bpm;
        double x = floor((now-downbeat)/oldDuration); // x is how many beats have passed since downbeat time
        double y = (x + 1.0) * oldDuration + downbeat; // y is the gridTime of the next beat on the basis of x
        if(newBpm <= 0.0) newBpm = 0.000001;
        // *** commenting out next two lines because of experiment with cumulative beat numbers ***
        // double newDuration = 60.0/newBpm;
        // double newDownbeat = y - (newDuration * (x+1.0));
        
        NSLog(@"beatsIssued = %ld",beatsIssued);
        [kvc setValue:[NSNumber numberWithDouble:newBpm] forKeyPath:@"beat.tempo"];
        [kvc setValue:[NSNumber numberWithDouble:y] forKeyPath:@"beat.downbeatTime"]; // *** was newDownbeat
        [kvc setValue:[NSNumber numberWithLong:beatsIssued] forKeyPath:@"beat.downbeatNumber"]; // ** experiment
    }
    else
    {
        if(newBpm<=0.0)newBpm = 0.000001;
        [kvc setValue:[NSNumber numberWithDouble:newBpm] forKeyPath:@"beat.tempo"];
    }
}

-(BOOL) handleOsc:(NSString*)address withParameters:(NSArray*)d fromHost:(NSString*)h port:(int)p
{
    if([address isEqual:@"/esp/beat/on"]) 
    {
        if([d count]!=1){postProblem(@"received /esp/beat/on with wrong number of parameters",self); return NO;}
        int x = [[d objectAtIndex:0] intValue];
        if(x)[self turnBeatOn]; else [self turnBeatOff];
        return YES;
    }
    else if([address isEqual:@"/esp/beat/tempo"])
    {
        if([d count]!=1){postProblem(@"received /esp/beat/tempo with wrong number of parameters",self); return NO;}
        float x = [[d objectAtIndex:0] floatValue];
        [self changeTempo:x];
        return YES;
    }
    else if([address isEqual:@"/esp/beat/cycleLength"])
    {
        if([d count]!=1){postProblem(@"received /esp/beat/cycleLength with wrong number of parameters",self); return NO;}
        int x = [[d objectAtIndex:0] intValue];
        if(x<=0)x=1;
        [kvc setValue:[NSNumber numberWithInt:x] forKeyPath:@"beat.cycleLength"];
        return YES;
    }
    return NO;
}

@end

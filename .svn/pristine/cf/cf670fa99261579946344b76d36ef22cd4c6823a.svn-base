//
//  EspKeyValueController.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspKeyValueController.h"
#import "EspGridDefs.h"

@implementation EspKeyValueController
@synthesize udp;
@synthesize osc;
@synthesize clock;
@synthesize model;

-(id) init
{
    self = [super init];
    keyPaths = [[NSMutableArray alloc] init];
    timeStamps = [[NSMutableDictionary alloc] init];

    NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
    [nc addObserver:self selector:@selector(newPeer:) name:@"newPeer" object:nil];
    
    return self;
}

-(void)addKeyPath:(NSString*)keyPath
{
    [timeStamps setObject:[NSNumber numberWithDouble:0.0] forKey:keyPath];
}

-(void) setValue:(id)value forKeyPath:(NSString *)keyPath
{
    [model setValue:value forKeyPath:keyPath];
    [self broadcastKeyPath:keyPath];
}

-(void) triggerRebroadcast
{   // send this message when a new peer joins, or whenever we make a change
    rebroadcastCount += 10; // i.e. rebroadcast all every 100ms for 1 second
    [NSTimer scheduledTimerWithTimeInterval:0.100
                                     target:self
                                   selector:@selector(rebroadcastAll:)
                                   userInfo:nil
                                    repeats:NO];
}

-(void)newPeer:(NSNotification*)n
{
    [self triggerRebroadcast];
}

-(void) rebroadcastAll:(NSTimer*)t
{
    for(NSString* x in [timeStamps allKeys])
    {
        [self rebroadcastEntry:x];
    }
    rebroadcastCount--;
    if(rebroadcastCount>0)
    {
        [NSTimer scheduledTimerWithTimeInterval:0.100
                                         target:self
                                       selector:@selector(rebroadcastAll:)
                                       userInfo:nil
                                        repeats:NO];
    }
}

-(void) broadcastKeyPath:(NSString*)keyPath
{
    if([timeStamps objectForKey:keyPath] != nil)
    { // this keyPath is shared on the grid
        id v = [model valueForKeyPath:keyPath];
        [self broadcastNewValue:v forKeyPath:keyPath];
    }
    else
    { // this keyPath is NOT shared on the grid
        postProblem(@"broadcastKeyPath asked to broadcast non-monitored path", self);
    }
}

-(void) broadcastNewValue:(id)value forKeyPath:(NSString*)keyPath
{
    NSNumber* timeStamp = [NSNumber numberWithDouble:[clock currentAdjustedTime]];
    [timeStamps setObject:timeStamp forKey:keyPath];    
    NSMutableDictionary* d = [[[NSMutableDictionary alloc] init] autorelease];
    [d setObject:keyPath forKey:@"keyPath"];
    [d setObject:value forKey:@"value"];
    [d setObject:timeStamp forKey:@"time"];
    // NSString* l = [NSString stringWithFormat:@"broadcastNewValue:%@ toValue:%@ at time %.2f",
    //               keyPath,value,[timeStamp doubleValue]];
    // postLog(l, self);
    [udp transmitOpcode:ESP_OPCODE_KVC withDictionary:d burst:1];
    [self triggerRebroadcast];
}

-(void) rebroadcastEntry:(NSString*)keyPath
{
    NSMutableDictionary* d = [[[NSMutableDictionary alloc] init] autorelease];
    [d setObject:keyPath forKey:@"keyPath"];
    [d setObject:[model valueForKeyPath:keyPath] forKey:@"value"];
    [d setObject:[timeStamps valueForKey:keyPath] forKey:@"time"];
    [udp transmitOpcode:ESP_OPCODE_KVC withDictionary:d burst:1];
}


-(BOOL) handleOpcode:(NSDictionary*)d 
{
    int opcode = [[d objectForKey:@"opcode"] intValue];
    
    if(opcode == ESP_OPCODE_KVC) // a broadcast dictionary value from somewhere 
    {
        NSString* keyPath = [d objectForKey:@"keyPath"]; VALIDATE_OPCODE_NSSTRING(keyPath);
        id value = [d objectForKey:@"value"];
        if(value == nil) { postWarning(@"received KVC with value==nil",self); return NO; }
        NSNumber* timeStampRcvd = [d objectForKey:@"time"]; VALIDATE_OPCODE_NSNUMBER(timeStampRcvd);
        NSNumber* timeStamp = [timeStamps objectForKey:keyPath];

        if(timeStamp != nil) 
        {
            if([timeStampRcvd compare:timeStamp] == NSOrderedDescending)
            {
                NSString* l = [NSString stringWithFormat:@"received remote broadcast for %@ with value %@ and newer time %@",keyPath,value,timeStampRcvd];
                postLog(l, self);
                [model setValue:value forKeyPath:keyPath];
                [timeStamps setValue:timeStampRcvd forKey:keyPath];
            }
        }
        else
        {
            postProblem(@"stored timestamp in ESP_OPCODE_KVC is nil", self);
            return NO;
        }
        return YES;
    }
 
    return NO;
}

@end

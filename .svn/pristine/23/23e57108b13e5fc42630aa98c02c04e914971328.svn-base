//
//  EspSocket.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspSocket.h"
#import "EspGridDefs.h"
#import <unistd.h>

#ifdef MINGW
#import <Ws2tcpip.h>
#endif

@implementation EspSocket
@synthesize delegate;

-(id) initWithPort: (int)p andDelegate:(id<EspSocketDelegate>)d
{
    self = [super init];
    socketRef = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(socketRef == -1) { postProblem(@"unable to create socket",self); }
    #ifndef MINGW
    int reuseOn = 1;
    #else
    const char reuseOn = 1;
    #endif
    setsockopt(socketRef, SOL_SOCKET, SO_BROADCAST, &reuseOn, sizeof(reuseOn));
    [self setDelegate:d];
    port = p;
    if([self bindToPort:port] == YES)
    {
        thread = [[NSThread alloc] initWithTarget:self selector:@selector(udpReceiveLoop) object:nil];
        [thread start];
    }
    return self;
}

-(void) dealloc
{
    close(socketRef);
    [super dealloc];
}

-(BOOL) bindToPort:(unsigned int)p
{
    #ifndef MINGW
    int reuseOn = 1;
    #else
    const char reuseOn = 1;
    #endif
    setsockopt(socketRef, SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn)); // maybe this isn't necessary?

    #ifndef MINGW
    int timestamp = 1;
    int r = setsockopt(socketRef, SOL_SOCKET, SO_TIMESTAMP, &timestamp, sizeof(timestamp));
    if(r!=0) postProblem(@"unable to set socket option", self);
    #endif

    // us.sin_len = sizeof(struct sockaddr_in); // probably needs to be commented out on Linux, seems to ok without on Cocoa too though
    us.sin_family = AF_INET;
    us.sin_port = htons(p);
    us.sin_addr.s_addr = htonl(INADDR_ANY);
    memset(&(us.sin_zero), 0, sizeof(us.sin_zero));
    if (bind(socketRef, (const struct sockaddr*)&us, sizeof(us)) < 0) {
        NSString* s = [NSString stringWithFormat:@"unable to bind to port %d",p];
        postProblem(s,self);
        close(socketRef);
        return NO;
    }
    NSLog(@"bound to port %d",p);
    return YES;
}

-(void) udpReceiveLoop
{
  [NSThread setThreadPriority:0.5]; // calling class method since instance method seems to not exist on GNUstep
    long bufferSize = 2048;
    for(;;)
    {
      NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
        char* buffer=malloc(bufferSize);
        if(buffer == (char*)nil) { postProblem(@"unable to allocate memory for buffer", self); return; }

        #ifndef MINGW
        struct msghdr msg;
        struct iovec entry;
        struct { struct cmsghdr cm; char control[512]; } control;
        memset(&msg, 0, sizeof(msg));
        msg.msg_iov = &entry;
        msg.msg_iovlen = 1;
        entry.iov_base = buffer;
        entry.iov_len = bufferSize;
        msg.msg_name = (caddr_t)&them;
        msg.msg_namelen = sizeof(them);
        msg.msg_control = &control;
        msg.msg_controllen = sizeof(control);
        long n = recvmsg(socketRef, &msg, 0);
        #else
        int s = sizeof(them);
        long n = recvfrom(socketRef, buffer, bufferSize, 0, (struct sockaddr*)&them, &s);
        #endif
        EspTimeType timeStamp = EspGridTime(); // get quickest user-level stamp in case kernel-level stamp is not available
    
        if(n>bufferSize)
        {
            postProblem(@"received more data than buffer can handle",self);
            continue;
        }
        if(n>0) {
            // parse kernel level timestamp, if available
#ifndef MINGW
            struct timeval *kernelTimeStamp = (struct timeval *)nil;
            for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg))
            {
                if(cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_TIMESTAMP)
                {   // NOTE: some online Linux example code uses SO_TIMESTAMP here instead of SCM_TIMESTAMP...
                    kernelTimeStamp = (struct timeval *)CMSG_DATA(cmsg);
                    timeStamp = ((double)kernelTimeStamp->tv_sec) + (1.0E-6*(double)kernelTimeStamp->tv_usec);
                }
            }
#endif
            buffer[n] = 0;
            NSString* h = [NSString stringWithCString:inet_ntoa(them.sin_addr) encoding:NSASCIIStringEncoding];
            if(n!=bufferSize) buffer = realloc(buffer,bufferSize); // reduce buffer size to save memory
            NSData* d = [[NSData alloc] initWithBytesNoCopy:buffer length:n freeWhenDone:YES];
            them.sin_port = ntohs(them.sin_port);
            // NSLog(@" %d: received %ld bytes from %@:%d",port,n,h,them.sin_port);
            [delegate dataReceived:d fromHost:h fromPort:them.sin_port atTime:timeStamp];
            [d release];
	    [pool drain];
        }
        else if (n==-1)
        {
            NSLog(@"***udpReceiveLoop error: %s",strerror(errno));
        }
    }
}

-(void)sendData: (NSData*)data toHost:(NSString*)host port:(int)p
{
    if(host == nil) { postProblem(@"can't send when host==nil",self); return; }
    if(p == 0) { postProblem(@"can't send when port==0", self); return; }
    struct sockaddr_in address;
    // address.sin_len = sizeof(struct sockaddr_in); // this line needs to be commented out for GNUstep, apparently ok without on cocoa
    address.sin_family = AF_INET;
    address.sin_port = htons(p);
#ifndef MINGW
    inet_pton(AF_INET, [host UTF8String], &(address.sin_addr.s_addr));
#else
    InetPton(AF_INET, [host UTF8String], &(address.sin_addr.s_addr));
#endif
    memset(&(address.sin_zero), 0, sizeof(address.sin_zero));
    const void *src = [data bytes];
    NSUInteger dsize = [data length];
    ssize_t r = sendto(socketRef, src, dsize, 0, (struct sockaddr*)&address, (socklen_t)sizeof(address));
    if(r != dsize) NSLog(@"*** sendto unable to send all %ld bytes to %@, bytes sent = %ld",dsize,host,r);
}

-(void)sendData: (NSData*)data toHost:(NSString*)host
{
    [self sendData:data toHost:host port:port];
}

@end

//
//  EspPeerList.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspPeerList.h" 
#import "EspGridDefs.h"

@implementation EspPeerList
@synthesize status;
@synthesize peers;
@synthesize selfInPeerList;



-(id) init {
    self = [super init];
    peers = [[NSMutableArray alloc] init];
    NSUserDefaults* x = [NSUserDefaults standardUserDefaults];
    [x addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:nil];
    [x addObserver:self forKeyPath:@"machine" options:NSKeyValueObservingOptionNew context:nil];
    [self setSelfNameAndMachine];
    [self updateStatus];
    return self;
}

-(void) dealloc
{
    [peers release];
    [super dealloc];
}

-(void)setSelfNameAndMachine
{
    NSUserDefaults* x = [NSUserDefaults standardUserDefaults];
    NSMutableDictionary* d = [[NSMutableDictionary alloc] init];
    [d setObject:[x stringForKey:@"name"] forKey:@"name"];
    [d setObject:[x stringForKey:@"machine"] forKey:@"machine"];
    [d setObject:@"unknown" forKey:@"ip"];
    [d setObject:@"n/a" forKey:@"latency"];
    [d setObject:@"n/a" forKey:@"lastBeaconStatus"];
    // [d setObject:[NSNumber numberWithInt: forKey:@"syncMode"]; // how to get syncmode from here?
    [d setObject:[NSNumber numberWithInt:ESPGRID_MAJORVERSION] forKey:@"majorVersion"];
    [d setObject:[NSNumber numberWithInt:ESPGRID_MINORVERSION] forKey:@"minorVersion"];
    if([peers count]>0)[peers replaceObjectAtIndex:0 withObject:d];
    else [peers addObject:d]; // question: couldn't we just do the addobject without the replaceObjectAtIndex 0?
    selfInPeerList = d;
}

-(void)setSelfAddress:(NSString*)address
{
    NSMutableDictionary* d = [peers objectAtIndex:0];
    if(![[d objectForKey:@"ip"] isEqualToString:address])
    {
        NSString* s = [NSString stringWithFormat:@"setting self address in peerList to %@",address];
        postLog(s, self);
        [d setValue:address forKey:@"ip"];
    }
}

-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    [self setSelfNameAndMachine];
}

-(void) receivedBeacon:(NSDictionary*)d
{
    // find or add the peer from whom the beacon has come
    NSString* name = [d objectForKey:@"name"];
    NSString* machine = [d objectForKey:@"machine"];
    NSMutableDictionary* peer = [self findPeerWithName:name andMachine:machine];
    if(peer == nil) peer = [self addNewPeer:d];
    
    // store time and index of received beacon for connection status and RBS purposes
    [peer setObject:[[d objectForKey:@"beaconCount"] copy] forKey:@"beaconCount"];
    EspTimeType beaconReceived = [[d objectForKey:@"timeReceived"] doubleValue];
    [peer setObject:[NSNumber numberWithDouble:beaconReceived] forKey:@"beaconReceived"];
    
    // update verbal indication that a beacon has been received recently
    [self willChangeValueForKey:@"peers"];
    [peer setObject:@"<10s" forKey:@"lastBeaconStatus"];
    [self didChangeValueForKey:@"peers"];
    
    // check and update IP address if necessary
    NSString* ip = [d objectForKey:@"ip"];
    [self updateIP:ip forPeer:peer];
    
    // update records of grid versions and sync mode
    [peer setObject:[[d objectForKey:@"syncMode"] copy] forKey:@"syncMode"];
    [peer setObject:[[d objectForKey:@"majorVersion"] copy] forKey:@"majorVersion"];
    [peer setObject:[[d objectForKey:@"minorVersion"] copy] forKey:@"minorVersion"];
}

-(void) receivedAck:(NSDictionary*)d
{
    // find or add the peer from whom the ack has come
    NSString* name = [d objectForKey:@"name"];
    NSString* machine = [d objectForKey:@"machine"];
    NSMutableDictionary* peer = [self findPeerWithName:name andMachine:machine];
    if(peer == nil) peer = [self addNewPeer:d];
    
    // check and update IP address if necessary
    NSString* ip = [d objectForKey:@"ip"];
    [self updateIP:ip forPeer:peer];
    
    // who is the ack for?
    NSString* ackForName = [d objectForKey:@"nameRcvd"];
    NSString* ackForMachine = [d objectForKey:@"machineRcvd"];
    NSMutableDictionary* ackFor = [self findPeerWithName:ackForName andMachine:ackForMachine];
    if(ackFor == nil) return; // later: change this so new peers can be added by implication from an ACK as well
    
    EspTimeType ackReceived = [[d objectForKey:@"timeReceived"] doubleValue]; // our raw clock when we received ACK
    EspTimeType adjustedClock = [[d objectForKey:@"adjustedClock"] doubleValue]; // sending peer's adjusted clock
    EspTimeType shiftedClock = adjustedClock - ackReceived; // shift frame of adjusted clock values so they are all relative to our raw clock
    NSLog(@"EspPeerList: ackReceived=%f  adjustedClock=%f  shiftedClock=%f",ackReceived,adjustedClock,shiftedClock);
    [peer setObject:[NSNumber numberWithDouble:shiftedClock] forKey:@"shiftedClock"];
    // take greatest shifted clock value, add our raw clock, compare to our adjusted clock for straight-up race calculations
    // the following 2 entries are just for debugging/display
    [peer setObject:[NSNumber numberWithDouble:ackReceived] forKey:@"ackReceived"];
    [peer setObject:[NSNumber numberWithDouble:adjustedClock] forKey:@"adjustedClock"];
    
    if(ackFor == selfInPeerList)
    {   // this is an ACK of our own beacon
        EspTimeType beaconClock = [[d objectForKey:@"beaconClock"] doubleValue]; // our raw clock when we sent our beacon
        EspTimeType rawClock = [[d objectForKey:@"rawClock"] doubleValue]; // peer's raw clock when they sent the ACK
        // calculate peer-specific latency
        EspTimeType latency = ackReceived - beaconClock;
        double oldLatency = [[peer objectForKey:@"latency"] doubleValue];
        if((latency*1000.0) < oldLatency)
        {
            NSString* l = [NSString stringWithFormat:@"EspPeerList: lower latency %f for %@-%@",latency,name,machine];
            postLog(l,self);
            [peer setValue:[NSNumber numberWithDouble:(latency*1000)]  forKey:@"latency"];
        }
        // calculate clock difference 
        EspTimeType difference = rawClock - ackReceived; // difference between two raw clocks (assuming latency 0 for better/worse)
        NSNumber* differenceObject = [NSNumber numberWithDouble:difference];
        [peer setObject:differenceObject forKey:@"lastAckDifference"];

        
        NSString* ipRcvd = [d objectForKey:@"ipRcvd"];
        [self setSelfAddress:ipRcvd];
        
    }
    else
    {   // this is an ACK of someone else' beacon
        NSNumber* ourBeaconCount = [ackFor objectForKey:@"beaconCount"];
        NSNumber* theirBeaconCount = [d objectForKey:@"beaconCount"];
        if([ourBeaconCount isEqualToNumber:theirBeaconCount])
        {   // beacon counts match so compare beacon clocks and store difference
            EspTimeType ourBeaconReceived = [[ackFor objectForKey:@"beaconReceived"] doubleValue];
            EspTimeType theirBeaconReceived = [[d objectForKey:@"beaconReceived"] doubleValue];
            EspTimeType difference = theirBeaconReceived - ourBeaconReceived; // stored difference is "how far ahead their clock is than ours"
            NSNumber* differenceObject = [NSNumber numberWithDouble:difference];
            [peer setObject:differenceObject forKey:@"referenceBeaconDifference"]; // store most recent clock difference for that peer
        } // else: unmatched beacon counts, for now simply let the data lapse
    }
}

-(EspTimeType) referenceBeaconDifferenceForName:(NSString*)name andMachine:(NSString*)machine
{
    NSMutableDictionary* p = [self findPeerWithName:name andMachine:machine];
    if(p)
    {
        NSNumber* rbdObject = [p objectForKey:@"referenceBeaconDifference"];
        if(rbdObject)
        {
            return [rbdObject doubleValue];
        }
        else
        {
            NSLog(@"rbdobject not found (peer %@ and machine %@) in referenceBeaconDifferenceForName",name,machine);
        }
    }
    else
    {
        NSLog(@"peer %@ and machine %@ not found in referenceBeaconDifferenceForName",name,machine);
    }
    return -100000.0;
}

-(void) updateIP:(NSString*)ip forPeer:(NSDictionary*)peer
{
    if(![[peer objectForKey:@"ip"] isEqual:ip])
    { 
        [self willChangeValueForKey:@"peers"];
        [peer setValue:ip forKey:@"ip"];
        [self didChangeValueForKey:@"peers"];
        NSString* s = [NSString stringWithFormat:@"changing IP for %@-%@ to %@",[peer objectForKey:@"name"],[peer objectForKey:@"machine"],ip];
        postLog(s, self);
    }
}


-(id) addNewPeer:(NSDictionary*)d 
{
    // extract parameters from dictionary passed from opcode
    NSString* name = [d objectForKey:@"name"];
    NSString* machine = [d objectForKey:@"machine"];
    NSString* ip = [d objectForKey:@"ip"];
    int theirMajorVersion = [[d objectForKey:@"majorVersion"] intValue];
    int theirMinorVersion = [[d objectForKey:@"minorVersion"] intValue];
    
    // check EspGrid version of peer/sender and warn in cases of mismatch
    if(theirMajorVersion < ESPGRID_MAJORVERSION ) 
    {
        NSString* s = [NSString stringWithFormat:@"%@-%@ is running old EspGrid %d.%2d",name,machine,theirMajorVersion,theirMinorVersion];
        postWarning(s,self);
    }
    else if(theirMajorVersion > ESPGRID_MAJORVERSION )
    {
        NSString* s = [NSString stringWithFormat:@"%@-%@ is running newer EspGrid %d.%2d",name,machine,theirMajorVersion,theirMinorVersion];
        postWarning(s,self);
    }
    else if(theirMinorVersion < ESPGRID_MINORVERSION)
    {
        NSString* s = [NSString stringWithFormat:@"%@-%@ is running old EspGrid %d.%2d",name,machine,theirMajorVersion,theirMinorVersion];
        postWarning(s,self);
    }
    else if(theirMinorVersion > ESPGRID_MINORVERSION)
    {
        NSString* s = [NSString stringWithFormat:@"%@-%@ is running newer EspGrid %d.%2d",name,machine,theirMajorVersion,theirMinorVersion];
        postWarning(s,self);
    }
    
    // add new peer to peerlist
    [self willChangeValueForKey:@"peers"];
    NSMutableDictionary* x = [[NSMutableDictionary alloc] init];
    [x setValue:name forKey:@"name"];
    [x setValue:machine forKey:@"machine"];
    [x setValue:ip forKey:@"ip"];
    [x setValue:[NSNumber numberWithInt:theirMajorVersion] forKey:@"majorVersion"];
    [x setValue:[NSNumber numberWithInt:theirMinorVersion] forKey:@"minorVersion"];
    [x setValue:[NSNumber numberWithLong:100000] forKey:@"latency"];
    
    [x setValue:[NSMutableArray array] forKey:@"latencies"]; // think we can remove this?
    
    [self setLastBeaconToNowFor:x];
    [peers addObject:x];
    [self didChangeValueForKey:@"peers"];
    NSString* s = [NSString stringWithFormat:@"adding %@-%@ at %@",name,machine,ip];
    postLog(s, self);
    [self updateStatus];
    return x;
}

-(void) setLastBeaconToNowFor:(NSString*)name machine:(NSString*)machine
{
    NSMutableDictionary* d = [self findPeerWithName:name andMachine:machine];
    [self setLastBeaconToNowFor:d];
}

-(void) setLastBeaconToNowFor:(NSMutableDictionary*)d
{
    EspTimeType now = EspGridTime();
    [self willChangeValueForKey:@"peers"];
    [d setObject:@"<10s" forKey:@"lastBeaconStatus"];
    [d setObject:[NSNumber numberWithDouble:now] forKey:@"lastBeacon"];
    [self didChangeValueForKey:@"peers"];
}

-(void) checkLastBeaconFrom:(NSMutableDictionary*)d
{
    EspTimeType now = EspGridTime();
    id thenObject = [d objectForKey:@"lastBeacon"];
    if (thenObject != nil)
    {
        EspTimeType then = [thenObject doubleValue];
        EspTimeType diff = now - then;
        [self willChangeValueForKey:@"peers"];
        if(diff < 10.0) { [d setObject:@"<10s" forKey:@"lastBeaconStatus"]; }
        else if(diff < 30.0) { [d setObject:@"<30s" forKey:@"lastBeaconStatus"]; }
        else if(diff < 60.0) { [d setObject:@"<60s" forKey:@"lastBeaconStatus"]; }
        else if(diff < 120.0) { [d setObject:@"<120s" forKey:@"lastBeaconStatus"]; }
        else
        {
            [d setObject:@"LOST" forKey:@"lastBeaconStatus"];
            NSString*s = [NSString stringWithFormat:@"lost contact with %@-%@ at %@ (removing)",
                          [d objectForKey:@"name"],[d objectForKey:@"machine"],[d objectForKey:@"ip"]];
            postLog(s,self);
            [peers removeObjectIdenticalTo:d];
            [self updateStatus];
        }
        [self didChangeValueForKey:@"peers"];
    } // else [post problem:@"thenObject == nil" from:self];
    // ignore this problem as a convenient way of not updating status for self
}

-(void) checkAllLastBeaconStatuses
{
    for(NSMutableDictionary* x in peers)
    {
        [self checkLastBeaconFrom:x];
    }
}

-(double) trackLatency:(double)latency fromName:(NSString*)name andMachine:(NSString*)machine
{
    NSMutableDictionary* peer = [self findPeerWithName:name andMachine:machine];
    if(peer != nil) 
    {
        // status quo latency algorithm - keeping track of the historical lowest ever latency
        double oldLatency = [[peer objectForKey:@"latency"] doubleValue];
        if((latency*1000.0) < oldLatency)
        {
            NSString* l = [NSString stringWithFormat:@"EspPeerList: lower latency %f for %@-%@",latency,name,machine];
            postLog(l,self);
            [peer setValue:[NSNumber numberWithDouble:(latency*1000)]  forKey:@"latency"];
            return latency;
        }
        else return oldLatency / 1000.0; 
    }
    postWarning(@"strange error in peerlist - tracking latency for unknown peer",self);
    return 100.0; 
}

-(id) findPeerWithName:(NSString*)name andMachine:(NSString*)machine
{
    // see if IP is already in database
    for(NSMutableDictionary* x in peers)
    {
        if([[x objectForKey:@"name"] isEqual:name])
        {
            if([[x objectForKey:@"machine"] isEqual:machine])
            {  // same name and machine
                return x;
            }
        }
    }
    return nil;
}

-(double) latencyForName:(NSString*)name andMachine:(NSString*)machine
{
    return [[[self findPeerWithName:name andMachine:machine] objectForKey:@"latency"] doubleValue]/1000.0; // experimenting here - this should make return value in seconds
}

-(long) peerCount
{
    return [peers count];
}

-(void) updateStatus
{
    long c = [self peerCount];
    if(c>1) {
        [self setStatus:[NSString stringWithFormat:@"%ld peers on grid",[self peerCount]]];
    }
    else 
    {
        [self setStatus:@"no peers found yet"];
    }
}

@end

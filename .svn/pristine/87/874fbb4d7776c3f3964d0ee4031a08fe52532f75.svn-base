//
//  EspInternalProtocol.m
//
//  This file is part of EspGrid.  EspGrid is (c) 2012,2013 by David Ogborn.
//
//  EspGrid is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  EspGrid is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with EspGrid.  If not, see <http://www.gnu.org/licenses/>.

#import "EspInternalProtocol.h"
#import "EspGridDefs.h"

@implementation EspInternalProtocol
@synthesize peerList;
@synthesize bridge;



-(id) init
{
    self = [super init];
    udpReceive = [[EspSocket alloc] initWithPort:5509 andDelegate:self];
    hashQueue = [[NSMutableArray alloc] init];
    for(int x=0;x<100;x++)[hashQueue addObject:[NSNull null]];
    return self;
}

-(void) dealloc
{
    [udpReceive release];
    [hashQueue release];
    [super dealloc];
}

-(void) setHandler:(id)h forOpcode:(int)o
{
    NSAssert(o < ESPUDP_MAX_HANDLERS, @"attempt to add opcode handler beyond maximum");
    handlers[o] = h; 
}

-(void) transmitDictionary:(NSDictionary*)d
{
    NSError* err = nil;
    NSData* data = [NSPropertyListSerialization dataWithPropertyList:d
                    format:NSPropertyListBinaryFormat_v1_0 options:0
                                                               error:&err];
    if(err != nil) {
        postProblem(@"unable to serialize property list (opcode) as NSData", self);
    } else {
        [self transmitData:data];
        [bridge transmitOpcode:d]; 
	} 
}

-(void) transmitDictionary:(NSDictionary*)d burst:(int)n
{
    NSError* err = nil;
    NSData* data = [NSPropertyListSerialization dataWithPropertyList:d
                                                              format:NSPropertyListBinaryFormat_v1_0 options:0
                                                               error:&err];
    if(err != nil) {
        postProblem(@"unable to serialize property list (opcode) as NSData", self);
    } else {
        [self transmitData:data burst:n];
        [bridge transmitOpcode:d]; // note: the burst behaviour not continued over bridge... ?
    }
}

-(void) transmitOpcode:(int)opcode withDictionary:(NSDictionary*)d
{
    NSMutableDictionary* d2 = [NSMutableDictionary dictionaryWithDictionary:d];
    [d2 setValue:[NSNumber numberWithInt:opcode] forKey:@"opcode"];
    [d2 setValue:[[NSUserDefaults standardUserDefaults] objectForKey:@"name"] forKey:@"name"];
    [d2 setValue:[[NSUserDefaults standardUserDefaults] objectForKey:@"machine"] forKey:@"machine"];
    [self transmitDictionary:d2];
}

-(void) transmitOpcode:(int)opcode withDouble:(double)x forKey:(NSString*)key
{
    NSNumber* n = [NSNumber numberWithDouble:x];
    NSMutableDictionary* d = [NSMutableDictionary dictionaryWithObject:n forKey:key];
    [self transmitOpcode:opcode withDictionary:d];
}

-(void) transmitOpcode:(int)opcode withLong:(long)x forKey:(NSString*)key
{
    NSNumber* n = [NSNumber numberWithLong:x];
    NSMutableDictionary* d = [NSMutableDictionary dictionaryWithObject:n forKey:key];
    [self transmitOpcode:opcode withDictionary:d];
}

-(void) transmitOpcode:(int)opcode withDictionary:(NSDictionary*)d burst:(int)n
{
    NSMutableDictionary* d2 = [NSMutableDictionary dictionaryWithDictionary:d];
    [d2 setValue:[NSNumber numberWithInt:opcode] forKey:@"opcode"];
    [d2 setValue:[[NSUserDefaults standardUserDefaults] objectForKey:@"name"] forKey:@"name"];
    [d2 setValue:[[NSUserDefaults standardUserDefaults] objectForKey:@"machine"] forKey:@"machine"];
    [d2 setValue:[NSNumber numberWithLong:messageHash] forKey:@"hash"];
    messageHash++;
    [self transmitDictionary:d2 burst:n];
}

-(void) transmitOpcode:(int)opcode withString:(NSString*)s forKey:(id)key
{
    NSDictionary* d = [NSDictionary dictionaryWithObject:s forKey:key];
    [self transmitOpcode:opcode withDictionary:d];
}

-(void) transmitOpcode:(int)opcode withString:(NSString*)s forKey:(id)key burst:(int)n
{
    NSDictionary* d = [NSDictionary dictionaryWithObject:s forKey:key];
    [self transmitOpcode:opcode withDictionary:d burst:n];
}

-(void) transmitData: (NSData*)data 
{
      [udpReceive sendData:data
                    toHost:[[NSUserDefaults standardUserDefaults] stringForKey:@"broadcast"]];
}

-(void) transmitData:(NSData*)data burst:(int)n
{
    for(int x=0;x<n;x++) {
        [udpReceive sendData:data
                      toHost:[[NSUserDefaults standardUserDefaults] stringForKey:@"broadcast"]];
    }
}

- (void)dataReceived:(NSData*)d fromHost:(NSString*)h fromPort:(int)p atTime:(EspTimeType)timestamp
{
    NSAssert(d != nil, @"data should not be nil");
    NSAssert(h != nil, @"host should not be nil");
    NSError* err = nil;
    NSMutableDictionary* plist =
    (NSMutableDictionary*)[NSPropertyListSerialization propertyListWithData:d
                                                                    options:NSPropertyListMutableContainers format:NULL error:&err];
    if(plist != nil) 
    {
        [plist setValue:[NSNumber numberWithDouble:timestamp] forKey:@"timeReceived"]; 
        [plist setValue:h forKey:@"ip"];
        [plist setValue:[NSNumber numberWithInt:p] forKey:@"port"];
        [self receivedOpcode:plist];
    }
    else 
    {
        NSString* s = [NSString stringWithFormat:@"unable to deserialize packet of length %lu into property list (opcode)",[d length]];
        postProblem(s, self);
    }
}

-(void) transmitOpcodeToSelf:(int)opcode withDictionary:(NSDictionary*)d
{
    NSMutableDictionary* d2 = [NSMutableDictionary dictionaryWithDictionary:d];
    [d2 setValue:[NSNumber numberWithInt:opcode] forKey:@"opcode"];
    [self handleOpcode:d2];
}

-(void) receivedOpcode: (NSDictionary*)d
{

    BOOL goAhead = NO;
    id hash = [d objectForKey:@"hash"];
    if(!hash) goAhead = YES; // process opcode if hash key not found in rcvd message...
    else if(![self isDuplicateMessage:d]) goAhead = YES; // ...or if not duplicate hash
    
    if(goAhead == YES) {
        if([[d objectForKey:@"name"] isEqual:[[NSUserDefaults standardUserDefaults] stringForKey:@"name"]]) {
            if([[d objectForKey:@"machine"] isEqual:[[NSUserDefaults standardUserDefaults] stringForKey:@"machine"]])
            { // name and machine are our own - so don't process message
            goAhead = NO;
            }
        }
        else if([d objectForKey:@"bridgeName"] != nil && [d objectForKey:@"bridgeMachine"] != nil)
        {   
            if([[d objectForKey:@"bridgeName"] isEqual:[[NSUserDefaults standardUserDefaults] stringForKey:@"name"]]) {
                if([[d objectForKey:@"bridgeMachine"] isEqual:[[NSUserDefaults standardUserDefaults] stringForKey:@"machine"]])
                { // since bridgeName and machine match our name this is is a packet rebroadcast by us from a bridge, so ignore
                    goAhead = NO; 
                }
            }
        }
    } // else NSLog(@"duplicate message");
    
    if(goAhead)
    {
        [self handleOpcode:d];
        [bridge retransmitOpcode:d];
    }

}

-(BOOL) handleOpcode: (NSDictionary*)d
{
    int opcode = [[d objectForKey:@"opcode"] intValue];
    id<EspHandleOpcode> h = handlers[opcode];
    if(h == nil) {
        NSString* s = [NSString stringWithFormat:@"no handler for opcode %d from %@-%@ at %@",opcode,[d objectForKey:@"name"],[d objectForKey:@"machine"],[d objectForKey:@"ip"]];
        postProblem(s,self);
    }
    [peerList setLastBeaconToNowFor:[d objectForKey:@"name"] machine:[d objectForKey:@"machine"]]; // ??? check this
    return [h handleOpcode:d];
}

-(BOOL) isDuplicateMessage: (NSDictionary*)msg
{
    NSString* h = [NSString stringWithFormat:@"%@-%@-%@",
                    [msg objectForKey:@"hash"],
                    [msg objectForKey:@"name"],
                   [msg objectForKey:@"machine"]];
    if([hashQueue containsObject:h]){
        return YES;   
    } 
    else {
        [hashQueue replaceObjectAtIndex:hashQueueIndex withObject:h];
        hashQueueIndex++;
        if(hashQueueIndex >= 100) hashQueueIndex = 0;
        return NO;       
    }
}


@end
